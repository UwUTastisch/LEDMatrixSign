#!/usr/bin/env python3
import argparse
import base64
import json
import os
import shutil
import subprocess
import tempfile

import requests


def get_img_specs(base_url, default_width=480, default_height=320):
    print(f"Fetching image specs from {base_url}/api/imgspec ...")
    try:
        r = requests.get(f"{base_url}/api/imgspec", timeout=5)
        r.raise_for_status()
        specs = r.json()
        width = specs.get("width", default_width)
        height = specs.get("height", default_height)
        print(f"Using recommended dimensions: {width}x{height}")
        return width, height
    except Exception as e:
        print(f"Failed to get image specs. Using default {default_width}x{default_height}. Error: {e}")
        return default_width, default_height


def extract_frames_with_ffmpeg(video_path, width, height, fps, max_frames=None):
    if not shutil.which("ffmpeg"):
        raise RuntimeError("ffmpeg not found in PATH. Please install ffmpeg.")

    tmp_dir = tempfile.mkdtemp(prefix="esp_video_frames_")
    print(f"Extracting frames into {tmp_dir} ...")

    # Scale + pad to match panel resolution while keeping aspect ratio
    vf_filter = (
        f"scale={width}:{height}:force_original_aspect_ratio=decrease,"
        f"pad={width}:{height}:(ow-iw)/2:(oh-ih)/2"
    )

    output_pattern = os.path.join(tmp_dir, "frame_%05d.bmp")

    cmd = [
        "ffmpeg",
        "-y",  # overwrite
        "-i", video_path,
        "-vf", vf_filter,
        "-r", str(fps),
    ]

    if max_frames is not None:
        cmd.extend(["-frames:v", str(max_frames)])

    cmd.append(output_pattern)

    print("Running:", " ".join(cmd))
    subprocess.run(cmd, check=True)

    # Collect generated frames
    frames = sorted(
        os.path.join(tmp_dir, f)
        for f in os.listdir(tmp_dir)
        if f.lower().endswith(".bmp")
    )

    if not frames:
        raise RuntimeError("No frames were generated by ffmpeg.")

    print(f"Generated {len(frames)} frame(s).")
    return tmp_dir, frames


def upload_frame(base_url, frame_path):
    filename = os.path.basename(frame_path)
    with open(frame_path, "rb") as f:
        bmp_base64 = base64.b64encode(f.read()).decode()

    payload = {
        "file": filename,
        "img": bmp_base64,
    }

    url = f"{base_url}/api/img"
    r = requests.post(url, json=payload)
    try:
        body = r.json()
    except Exception:
        body = r.text

    if r.status_code != 200:
        raise RuntimeError(
            f"Failed to upload {filename}: {r.status_code} {body}"
        )

    return filename


def create_img_chain(base_url, filenames, fps, chain_num=0):
    url = f"{base_url}/api/imgchain"
    payload = {
        "chain": filenames,
        "fps": fps,
        "num": chain_num,
    }
    print(f"Creating image chain with {len(filenames)} frames at {fps} FPS (num={chain_num}) ...")
    r = requests.post(url, json=payload)
    try:
        body = r.json()
    except Exception:
        body = r.text

    if r.status_code != 200:
        raise RuntimeError(
            f"Failed to create image chain: {r.status_code} {body}"
        )

    print("Chain created successfully.")
    print("Device response:", body)


def main():
    parser = argparse.ArgumentParser(
        description="Convert a video (mp4/mov) into ESP image frames and create a playable image chain."
    )
    parser.add_argument("video", help="Path to the input video file (mp4, mov, etc.)")
    parser.add_argument(
        "--esp-ip",
        type=str,
        help="IP address of the ESP device (overrides $ESP_IP)",
    )
    parser.add_argument(
        "--fps",
        type=int,
        default=12,
        help="Playback FPS for the image chain (default: 12)",
    )
    parser.add_argument(
        "--chain-num",
        type=int,
        default=0,
        help="Image chain slot/number to use on the device (default: 0)",
    )
    parser.add_argument(
        "--max-frames",
        type=int,
        help="Optional limit on number of frames to extract & upload",
    )
    parser.add_argument(
        "--keep-frames",
        action="store_true",
        help="Keep generated BMP frames on disk (for debugging).",
    )

    args = parser.parse_args()

    esp_ip = args.esp_ip or os.environ.get("ESP_IP", "192.168.1.123")
    base_url = f"http://{esp_ip}"
    print(f"Using ESP at {base_url}")

    if not os.path.isfile(args.video):
        raise SystemExit(f"Video file not found: {args.video}")

    # 1. Get image specs from device
    width, height = get_img_specs(base_url)

    # 2. Extract frames from video
    frames_dir = None
    try:
        frames_dir, frame_paths = extract_frames_with_ffmpeg(
            video_path=args.video,
            width=width,
            height=height,
            fps=args.fps,
            max_frames=args.max_frames,
        )

        # 3. Upload frames
        uploaded_filenames = []
        for i, frame in enumerate(frame_paths, 1):
            print(f"Uploading frame {i}/{len(frame_paths)}: {os.path.basename(frame)}")
            filename_on_device = upload_frame(base_url, frame)
            uploaded_filenames.append(filename_on_device)

        # 4. Create image chain on device (this typically starts playback, depending on firmware)
        create_img_chain(base_url, uploaded_filenames, fps=args.fps, chain_num=args.chain_num)

    finally:
        # 5. Clean up
        if frames_dir and not args.keep-frames:
            shutil.rmtree(frames_dir, ignore_errors=True)
            print(f"Cleaned up temporary frames in {frames_dir}")
        elif frames_dir:
            print(f"Frames kept in {frames_dir}")


if __name__ == "__main__":
    main()
